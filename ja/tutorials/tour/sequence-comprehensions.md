---
layout: tutorial
title: Sequence Comprehensions

disqus: true

tutorial: scala-tour
num: 7
tutorial-previous: compound-types
tutorial-next: extractor-objects
---

Scala は *シーケンス内包表記* について簡易的な表記法を提供します。 内包表記は `for (enumerators) yield e` という形をしており、 `enumerators` はセミコロンで区切られた列挙子のリストを参照します。 *列挙子* は新しい変数を導入するジェネレータまたはフィルタです。 内包表記は列挙子によって生成された各束縛の本体 `e` を評価し、値のシーケンスを返します。
Scala offers a lightweight notation for expressing *sequence comprehensions*. Comprehensions have the form `for (enumerators) yield e`, where `enumerators` refers to a semicolon-separated list of enumerators. An *enumerator* is either a generator which introduces new variables, or it is a filter. A comprehension evaluates the body `e` for each binding generated by the enumerators and returns a sequence of these values.

次に例を示します。:
Here is an example:
 
    object ComprehensionTest1 extends App {
      def even(from: Int, to: Int): List[Int] =
        for (i <- List.range(from, to) if i % 2 == 0) yield i
      Console.println(even(0, 20))
    }
 
関数の中の for 式は新しい `Int` 型の変数 `i` を導入し、リスト `List(from, from + 1, ..., to - 1)` のすべての値に順次束縛します。 ガード `if i % 2 == 0` は奇数の値を取り除き、(i だけからなる)本体の処理は偶数についてのみ評価されます。 最終的に、 for 式全体は偶数のリストを返します。
The for-expression in function introduces a new variable `i` of type `Int` which is subsequently bound to all values of the list `List(from, from + 1, ..., to - 1)`. The guard `if i % 2 == 0` filters out all odd numbers so that the body (which only consists of the expression i) is only evaluated for even numbers. Consequently, the whole for-expression returns a list of even numbers.

上のプログラムは下記の値を生成します。:

    List(0, 2, 4, 6, 8, 10, 12, 14, 16, 18)

次はより複雑な例で、 `0` から `n-1` までの数のペアのうち合計が与えられた値 `v` に日吉鋳物をすべて計算します。:
Here is a more complicated example which computes all pairs of numbers between `0` and `n-1` whose sum is equal to a given value `v`:
 
    object ComprehensionTest2 extends App {
      def foo(n: Int, v: Int) =
        for (i <- 0 until n;
             j <- i until n if i + j == v) yield
          Pair(i, j);
      foo(20, 32) foreach {
        case (i, j) =>
          println("(" + i + ", " + j + ")")
      }
    }
 
この例から、内包表記がリストに制限されないことがわかります。 最初のプログラムでは代わりにイテレータを使っていました。 (適切な型をもつ)操作 `filterWith`, `map`, `flatMap` ををサポートするすべてのデータ型はシーケンス内包表記で使用できます。
This example shows that comprehensions are not restricted to lists. The previous program uses iterators instead. Every datatype that supports the operations `filterWith`, `map`, and `flatMap` (with the proper types) can be used in sequence comprehensions.

上のプログラムのアウトプットは下のようになります。:
Here's the output of the program:

    (13, 19)
    (14, 18)
    (15, 17)
    (16, 16)

シーケンス内包表記にも特別な形式 `Unit` があります。 ジェネレータのリストとフィルターで作られる束縛は、副作用を起こすために使われます。 そのようなシーケンス内包表記を使用する場合、プログラマはキーワード `yield` を除く必要があります。
There is also a special form of sequence comprehension which returns `Unit`. Here the bindings that are created from the list of generators and filters are used to perform side-effects. The programmer has to omit the keyword `yield` to make use of such a sequence comprehension.
下のプログラムは、上のプログラムと同じですが、 `Unit` を返す特別な for 内包表記を使用しています。:
Here's a program which is equivalent to the previous one but uses the special for comprehension returning `Unit`:
 
    object ComprehensionTest3 extends App {
      for (i <- Iterator.range(0, 20);
           j <- Iterator.range(i, 20) if i + j == 32)
        println("(" + i + ", " + j + ")")
    }

